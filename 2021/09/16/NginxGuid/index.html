<!DOCTYPE html>
<html lang="zh-CN,zh-cn,default">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Desperado">


    <meta name="subtitle" content="xstar">




<title>Nginx指引 | xstar</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">XSTAR</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">XSTAR</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Nginx指引</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Desperado</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">九月 16, 2021&nbsp;&nbsp;14:03:26</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/DevOps/">DevOps</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="Nginx指引"><a href="#Nginx指引" class="headerlink" title="Nginx指引"></a>Nginx指引</h2><p>通过本文，你将了解Nginx的基本使用和Nginx的基本知识。</p>
<h3 id="Nginx-安装（Ubuntu）"><a href="#Nginx-安装（Ubuntu）" class="headerlink" title="Nginx 安装（Ubuntu）"></a>Nginx 安装（Ubuntu）</h3><p>直接使用apt命令安装nginx：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新源</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">sudo apt install nginx</span></span><br></pre></td></tr></table></figure>

<h3 id="Nginx的启用、停止和重新加载配置"><a href="#Nginx的启用、停止和重新加载配置" class="headerlink" title="Nginx的启用、停止和重新加载配置"></a>Nginx的启用、停止和重新加载配置</h3><p>nginx启动以后，可以通过”nginx -s &lt;signal&gt;“的指令来对nginx执行启用、停止、和重新加载配置文件的操作，singnal说明如下：</p>
<ul>
<li>stop: 快速关闭</li>
<li>quit: 优雅关闭（等处理完所有处理中的请求后再关闭）</li>
<li>reload: 重新加载配置文件</li>
<li>reopen: 重新打开日志文件</li>
</ul>
<p>例如：我们要等所有当前正在处理的请求结束后停止nginx进程，我们可以执行以下命令：</p>
<blockquote>
<p>nginx -s quit</p>
</blockquote>
<p>当我们修改了nginx的配置文件后，并不会马上生效。要使其生效需要执行以下命令：</p>
<blockquote>
<p>nginx -s reload</p>
</blockquote>
<p>一旦nginx的master 进程接收到reload指令，它会先去检查config文件的合法性并尝试应用新的配置。如果可以成功应用，master进程将开启一个新的worder进程并发送一个关闭命令的消息到旧的worker进程。否则master进程将回滚更改并继续使用旧配置。旧的worker进程收到关闭命令后，停止接受新的连接并继续处理正在处理中的请求，直到所有请求都处理完毕后结束进程。</p>
<h3 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h3><p>nginx由配置文件中指定的指令控制模块组成。指令分为<strong>简单指令</strong>和<strong>块指令</strong>。简单指令由名称和参数组成，以空格分隔并以分号（；）结尾。块指令结构同简单指令一样，不同的是块指令通过{}来包住指令，如果块指令包含了其他指令，这个被称为上下文（context）。比如：events、http、server、location。</p>
<p>放置在配置文件中其他任何上下文中的指令，可以称为主上下文（main context）。events和http指令在主上下文里，server在http指令中，location在server指令中。</p>
<p>#符号及之后的内容是注释。</p>
<h3 id="部署静态页面"><a href="#部署静态页面" class="headerlink" title="部署静态页面"></a>部署静态页面</h3><p>web服务器一项重要的任务就是提供静态文件的访问。下面，我们将实现通过不同的URL来访问服务器上不同路径下文件：/data/wwww目录下面存放静态文件，/data/images目录现面存放图片，我们通过配置location来实现通过url（<a target="_blank" rel="noopener" href="http://127.0.0.1)访问/data/wwww%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84index.html%E6%96%87%E4%BB%B6%EF%BC%8C%E9%80%9A%E8%BF%87%EF%BC%88http://127.0.0.1/images/avta.png%EF%BC%89%E8%AE%BF%E9%97%AE/data/images%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84avta.png">http://127.0.0.1）访问/data/wwww目录下的index.html文件，通过（http://127.0.0.1/images/avta.png）访问/data/images目录下的avta.png</a>图片。</p>
<p>1.在/etc/nginx/conf.d/目录下创建test.conf文件，文件内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">127.0.0.1</span>;</span><br><span class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">        <span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line"><span class="comment"># 浏览器输入ip时，会访问/data/www目录下的index.html文件 </span></span><br><span class="line"> <span class="attribute">location</span> / &#123;</span><br><span class="line">     <span class="attribute">root</span>  /data/www;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment"># 浏览器输入ip/iamges/avta.png时，会访问/data/images/目录下的avta.png文件</span></span><br><span class="line"> <span class="attribute">location</span>  /images/ &#123;</span><br><span class="line">     <span class="attribute">root</span>  /data;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2.重新加载配置文件</p>
<blockquote>
<p>sudo nginx -s reload</p>
</blockquote>
<p>3.浏览器访问nginx下的文件</p>
<blockquote>
<p>127.0.0.1</p>
<p>127.0.0.1/images/avta.png</p>
</blockquote>
<h3 id="设置简单的代理服务"><a href="#设置简单的代理服务" class="headerlink" title="设置简单的代理服务"></a>设置简单的代理服务</h3><p>nginx的常见用途之一是服务器代理。服务器接受处理请求，把请求结果返回给代理服务，代理服务返回给客户端。</p>
<p>现在我们在服务器上5000端口有个服务，服务器上访问如下结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;ingress&quot;,&quot;nginx&quot;]&#125;</span><br></pre></td></tr></table></figure>

<p>nginx对外暴露端口80，IP地址<a target="_blank" rel="noopener" href="http://172.22.15.212/%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%BD%93%E6%88%91%E4%BB%AC%E8%AE%BF%E9%97%AEhttp://172.22.15.212/v2/_catalog%E8%83%BD%E8%AF%B7%E6%B1%82%E5%88%B05000">http://172.22.15.212/，现在当我们访问http://172.22.15.212/v2/_catalog能请求到5000</a>端口的内容。</p>
<p>配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">172.22.15.212</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line">        <span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line">        <span class="attribute">location</span> /v2/_catalog &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span>  http://127.0.0.1:5000;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host $proxy_host;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新加载配置<strong>nginx -s reload</strong>后，访问<a target="_blank" rel="noopener" href="http://172.22.15.212/v2/_catalog">http://172.22.15.212/v2/_catalog</a>后返回</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;repositories&quot;:[&quot;ingress&quot;,&quot;nginx&quot;]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nginx怎么处理一个请求"><a href="#Nginx怎么处理一个请求" class="headerlink" title="Nginx怎么处理一个请求"></a>Nginx怎么处理一个请求</h3><h4 id="基于名称的虚拟服务（Name-based-virtual-servers）"><a href="#基于名称的虚拟服务（Name-based-virtual-servers）" class="headerlink" title="基于名称的虚拟服务（Name-based virtual servers）"></a>基于名称的虚拟服务（Name-based virtual servers）</h4><p>nginx首先决定收到的请求由哪个服务/服务器来进行处理。如下例子，首先有三个服务都监听80端口，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，nginx先根据请求的header中的host字段来决定该请求由哪个服务去处理，如果都没有匹配上，则让默认的配置去处理。在上面的例子中，默认的处理则是第一个server（nginx默认的方式）。也可以通过在listen指令后面添加default_server显式的设置默认的处理服务，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>default_server 要在0.8.21及以上版本支持，更早的版本请使用default</p>
</blockquote>
<h4 id="如何禁止处理未定义的服务名称"><a href="#如何禁止处理未定义的服务名称" class="headerlink" title="如何禁止处理未定义的服务名称"></a>如何禁止处理未定义的服务名称</h4><p>如果不允许处理在header中携带host字段的请求，可以如下定义：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">return</span>      <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面，通过设置server_name为一个空的字符串,它将匹配没有“Host”头字段的请求，并返回一个特殊的 nginx 非标准代码 444 来关闭连接。</p>
<h4 id="基于名称和IP的混合虚拟服务"><a href="#基于名称和IP的混合虚拟服务" class="headerlink" title="基于名称和IP的混合虚拟服务"></a>基于名称和IP的混合虚拟服务</h4><p>让我们来看一个监听不同IP地址的配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">192.168.1.1:80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">192.168.1.1:80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">192.168.1.2:80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此配置中，nginx 首先根据服务器块的监听指令测试请求的 IP 地址和端口。然后，它根据与 IP 地址和端口匹配的服务器块的 server_name 条目测试请求的“主机”标头字段。如果server_name未匹配到，则采用默认的servier处理。例如在IP为192.168.1.1:80端口收到域名为<a href="http://www.example.com的请求，他将采用192.168.1.1:80">www.example.com的请求，他将采用192.168.1.1:80</a> 默认server，即第一个配置处理。</p>
<p>如前所述，默认服务器是监听端口的一个属性，可以为不同的端口定义不同的默认服务器：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">192.168.1.1:80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">192.168.1.1:80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">192.168.1.2:80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一个简单的PHP站点配置"><a href="#一个简单的PHP站点配置" class="headerlink" title="一个简单的PHP站点配置"></a>一个简单的PHP站点配置</h4><p>下面我们通过一个简单的例子来看看nginx如何来为一个请求选择对应的服务：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.org www.example.org;</span><br><span class="line">    <span class="attribute">root</span>        /data/www;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>   index.html index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* \.(gif|jpg|png)$</span> &#123;</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span>  localhost:<span class="number">9000</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME</span><br><span class="line">                      $document_root$fastcgi_script_name;</span><br><span class="line">        <span class="attribute">include</span>       fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论上面的location顺序如何，nginx 首先搜索由文字字符串给出的最具体的前缀位置。在上面的配置中，唯一的前缀位置是“/”，并且由于它匹配任何请求，因此将用作最后的手段。然后 nginx 按照配置文件中列出的顺序检查正则表达式给出的位置。第一个匹配的表达式停止搜索，nginx 将使用这个位置。如果没有正则表达式匹配请求，则 nginx 使用之前找到的最具体的前缀位置。</p>
<p>需要注意的，所有类型的location仅匹配不带参数的请求部分。</p>
<p>现在让我们看看上面的配置如何处理请求：</p>
<ul>
<li>“/logo.gif”，首先匹配到“/”location，然后匹配到正则表达式<code>\.(gif|jpg|png)$</code>，因此，它会被后面的location处理，使用<code>root  /data/wwww</code>指令匹配到文件 /data/www/logo.gif返回给客户端。</li>
<li>“/inde.php”，也是首先匹配到“/”location，然后匹配到正则表达式<code>\.php$</code>。因此，它被后面的location处理，并将请求传给监听<code>localhost:9000</code>的FastCGI服务，<code>fastcgi_param</code> 指令将 FastCGI 参数 <code>SCRIPT_FILENAME</code> 设置为<code>“/data/www/index.php”</code>，FastCGI 服务器执行该文件。变量 $document_root 等于 root 指令的值，变量 $fastcgi_script_name 等于请求 URI，即“/index.php”。</li>
<li>“/about.html”，只匹配到“/”location，因此在该位置处理。使用指令<code>“root /data/www”</code> 将请求映射到文件 <code>/data/www/about.html</code> 并返回客户端。</li>
<li>“/”，这个请求相对比较复杂，首先它匹配到“/”location，然后index指令会根据root指令来判断是否存在 <code>/data/www/index.html</code> 文件，如果不存在，则查找index.php文件，若存在则该指令执行内部重定向到“/index.php”，并且 nginx 再次搜索location，就好像请求是由客户端发送的一样。正如我们之前看到的，重定向的请求最终将由 FastCGI 服务器处理。</li>
</ul>
<h3 id="Server配置中的server-name"><a href="#Server配置中的server-name" class="headerlink" title="Server配置中的server_name"></a>Server配置中的server_name</h3><p>server块指令中的server_name指令用于决定路由请求到哪一个服务器去处理。它支持精确匹配、通配符以及正则。看下面例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  example.org  www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  <span class="regexp">*.example.org</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  <span class="regexp">mail.*</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  ~^(?&lt;user&gt;.+)\.example\.net$;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过名称路由服务，当匹配多个时，比如通配符和正则，将按照下面的规则来进行选择最终匹配：</p>
<ol>
<li>精确匹配</li>
<li>以*开头的最长匹配，如：*.example.org</li>
<li>以*结尾的最长匹配，如：mail.*</li>
<li>按照在文件出现的顺序，第一个匹配的正则表达式</li>
</ol>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>*通配符只能在名称的开始或者结尾，并且时在<code>.</code>的边上。像<code>www.*.example.org</code>和<code>w*.example.org</code>都是不合法的。可以使用正则表达式指定这些名称，例如<code>~^www\..+\.example\.org$</code>和<code>~^w.*\.example\.org$</code>。星号可以匹配多个名称部分。名称<code>*.example.org</code>不仅匹配 <code>www.example.org</code>，还匹配 <code>www.sub.example.org</code>。</p>
<p>注意：<code>.example.org</code>形式的特殊通配符名称可用于匹配确切名称<code>example.org</code>和通配符名称<code>*.example.org</code></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>nginx 使用的正则表达式与 Perl 编程语言 (PCRE) 使用的正则表达式兼容。要使用正则表达式，服务器名称必须以波浪号字符开头：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_name</span>  ~^www\d+\.example\.net$;</span><br></pre></td></tr></table></figure>

<p>否则，它将被视为精确匹配名称，或者如果表达式包含星号，则将其视为通配符名称（并且很可能被视为无效名称）。不要忘记设置“^”和“$”锚点。它们在语法上不是必需的，但在逻辑上是必需的。另请注意，域名点应使用反斜杠进行转义。应引用包含字符“{”和“}”的正则表达式：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_name</span>  <span class="string">&quot;~^(?&lt;name&gt;\w\d&#123;1,3&#125;+)\.example\.net$&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>否则 nginx 将无法启动并显示错误消息：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directive &quot;server_name&quot; is not terminated by &quot;;&quot; in ...</span><br></pre></td></tr></table></figure>

<p>命名的正则表达式捕获可以稍后用作变量：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span>   ~^(www\.)?(?&lt;domain&gt;.+)$;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /sites/$domain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PCRE 库支持使用以下语法的命名捕获：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?&lt;name&gt;	Perl 5.10 compatible syntax, supported since PCRE-7.0</span><br><span class="line">?&#x27;name&#x27;	Perl 5.10 compatible syntax, supported since PCRE-7.0</span><br><span class="line">?P&lt;name&gt;Python compatible syntax, supported since PCRE-4.0</span><br></pre></td></tr></table></figure>

<p>如果 nginx 无法启动并显示错误消息：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcre_compile() failed: unrecognized character after (?&lt; in ...</span><br></pre></td></tr></table></figure>

<p>这意味着 PCRE 库很旧，应该尝试使用语法“?P<name>”。捕获也可以以数字形式使用：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span>   ~^(www\.)?(.+)$;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /sites/<span class="variable">$2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这种用法应仅限于简单的情况（如上述），因为数字参考很容易被覆盖。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>有一些名称会被特殊处理。</p>
<p>如果需要在非默认的server块中处理没有host头的请求，可以指定一个空字符串的名称，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  example.org  www.example.org  <span class="string">&quot;&quot;</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果server_name指令未在server块中指定，则使用空字符串作为server_name。如果server_name 定义为<code>$hostname</code>，则使用hostname。</p>
<p>如果有人使用 IP 地址而不是服务器名称发出请求，“Host”请求头字段将包含 IP 地址，并且可以使用 IP 地址作为服务器名称来处理请求：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  example.org</span><br><span class="line">                 www.example.org</span><br><span class="line">                 <span class="string">&quot;&quot;</span></span><br><span class="line">                 <span class="number">192.168.1.1</span></span><br><span class="line">                 ;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在包罗万象的服务器示例中，可以看到奇怪的名称“_”：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>  default_server;</span><br><span class="line">    <span class="attribute">server_name</span>  _;</span><br><span class="line">    <span class="attribute">return</span>       <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面没有任何特别之处，只是一个无效域名。还有其他诸如<code>--</code>和<code>!@#</code> 之类。</p>
<h4 id="国际化名称"><a href="#国际化名称" class="headerlink" title="国际化名称"></a>国际化名称</h4><p>国际化域名应该在server_name中只用ASCII表示，如</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  xn--e1afmkfd.xn--80akhbyknj4f;  <span class="comment"># пример.испытание</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><p>精确匹配名称、以*开头的通配符和以*结尾的通配符是和端口绑定，保存在三张哈希表里中。哈希表的大小在配置阶段进行了优化，以便可以找到具有最少 CPU 缓存未命中的名称。</p>
<p>匹配过程顺序是  精确名称&gt;以*开头的通配符&gt;以*结尾的通配符&gt;正则,所以建议是对于server_name的配置尽量是精确更好。</p>
<p>如果定义了大量服务器名称，或者定义了异常长的服务器名称，则可能需要在 http 级别调整 server_names_hash_max_size 和 server_names_hash_bucket_size 指令。 server_names_hash_bucket_size 指令的默认值可能等于 32、64 或其他值，具体取决于 CPU 缓存行大小。</p>
<h3 id="nginx作为负载均衡"><a href="#nginx作为负载均衡" class="headerlink" title="nginx作为负载均衡"></a>nginx作为负载均衡</h3><p>nginx 支持以下负载均衡机制：</p>
<ul>
<li>轮询：对请求以循环的方式进行分发</li>
<li>最少连接：下一个请求分配给活动连接数最少的服务器</li>
<li>IP哈希：使用散列函数确定应该为下一个请求选择哪个服务器（基于客户端的 IP 地址）</li>
</ul>
<p>默认是使用轮询方式，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attribute">upstream</span> myapp1 &#123;</span><br><span class="line">        <span class="attribute">server</span> srv1.example.com;</span><br><span class="line">        <span class="attribute">server</span> srv2.example.com;</span><br><span class="line">        <span class="attribute">server</span> srv3.example.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://myapp1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果服务器的性能不同，也可以根据不同的配置性能来进行权重分配，这样在性能高的服务器能接受更多的请求，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attribute">upstream</span> myapp1 &#123;</span><br><span class="line">        <span class="attribute">server</span> srv1.example.com  weight=<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">server</span> srv2.example.com;</span><br><span class="line">        <span class="attribute">server</span> srv3.example.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://myapp1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用最少连接数如下：</span><br><span class="line"></span><br><span class="line">```nginx</span><br><span class="line">    <span class="attribute">upstream</span> myapp1 &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        <span class="attribute">server</span> srv1.example.com;</span><br><span class="line">        <span class="attribute">server</span> srv2.example.com;</span><br><span class="line">        <span class="attribute">server</span> srv3.example.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://myapp1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，轮询和最少连接方法两次请求可能会分发到不同的服务器，所以需要对session 做些处理，能保证即便分发不同的服务器，能正常的处理会话。</p>
<p>如果需要保证同个客户端的多次请求被分发到同个服务器，可以使用IP哈希的方式，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attribute">upstream</span> myapp1 &#123;</span><br><span class="line">         ip_hash;</span><br><span class="line">        <span class="attribute">server</span> srv1.example.com;</span><br><span class="line">        <span class="attribute">server</span> srv2.example.com;</span><br><span class="line">        <span class="attribute">server</span> srv3.example.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://myapp1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为负载均衡，nginx支持服务器健康检查。如果来自特定服务器的响应失败并出现错误，nginx 会将此服务器标记为失败，并在一段时间内尝试避免为后续入站请求选择此服务器。</p>
<p><code>max_fails</code> 指令设置在 <code>fail_timeout</code> 期间应该发生的与服务器通信的连续不成功尝试次数。默认情况下，<code>max_fails</code> 设置为 1。设置为 0 时，将禁用此服务器的健康检查。 <code>fail_timeout</code> 参数还定义了服务器将被标记为失败的时间。在服务器故障后的 <code>fail_timeout</code> 间隔之后，nginx 将开始使用实时客户端的请求优雅地探测服务器。如果探测成功，则服务器被标记为活动服务器。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>[1].<a target="_blank" rel="noopener" href="https://nginx.org/en/docs/">nginx documentation</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Desperado</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://xstar.life/2021/09/16/NginxGuid/">http://xstar.life/2021/09/16/NginxGuid/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/nginx/"># nginx</a>
                    
                        <a href="/tags/nginx-guide/"># nginx guide</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/12/01/RedirectAndLB/">重定向和负载均衡</a>
            
            
            <a class="next" rel="next" href="/2021/06/30/rocket-mq-install/">RocketMQ安装</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备2021008460号-1</a>|© Desperado | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
